<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# clifford

```go
import "github.com/chriso345/clifford"
```

Package clifford is a CLI argument parsing library for Go that uses reflection and struct tags to define command\-line interfaces declaratively.

It supports positional arguments, short and long flags, required arguments, and automatic generation of help and version output.

The library is designed to be easy to use and integrate into Go CLI tools, providing a clean API for defining and parsing command\-line parameters.

<details><summary>Example (Defaults)</summary>
<p>

Example\_defaults demonstrates default values are applied when flags are omitted.

```go
package main

import (
	"fmt"
	"os"

	"github.com/chriso345/clifford"
)

func main() {
	os.Args = []string{"app"}
	target := struct {
		clifford.Clifford `name:"app" desc:"App showing defaults"`

		Port struct {
			Value             int `default:"8080"`
			clifford.Clifford `long:"port" desc:"Port to run the server on"`
		}
	}{}

	err := clifford.Parse(&target)
	if err != nil {
		panic(err)
	}
	fmt.Println("Port:", target.Port.Value)
}
```

#### Output

```
Port: 8080
```

</p>
</details>

<details><summary>Example (Disable_shorthand)</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/chriso345/clifford"
)

func main() {
	// Demonstrate disabling -h/-v short forms on the top-level command
	target := struct {
		clifford.Clifford `name:"no-shorts" version:"0.1.0" help_short:"false" version_short:"false"`
		clifford.Help
		clifford.Version
	}{}

	if _, err := clifford.BuildHelp(&target, false); err != nil {
		panic(err)
	}
	fmt.Println("version")
}
```

#### Output

```
version
```

</p>
</details>

<details><summary>Example (Error_types)</summary>
<p>

Example\_error\_types demonstrates checking for specific error kinds with errors.Is and accessing details with errors.As.

```go
package main

import (
	"fmt"
	"os"

	stderrors "errors"

	"github.com/chriso345/clifford"
	"github.com/chriso345/clifford/errors"
)

func main() {
	os.Args = []string{"app"}
	target := struct {
		clifford.Clifford `name:"app"`

		File struct {
			Value             string
			clifford.Required `required:"true"`
		}
	}{}

	err := clifford.Parse(&target)
	if err == nil {
		fmt.Println("no error")
		return
	}

	if stderrors.Is(err, errors.ErrMissingArg) {
		fmt.Println("missing argument detected")
	}

	var ma errors.MissingArgError
	if stderrors.As(err, &ma) {
		fmt.Println("missing field:", ma.Field)
	}

}
```

#### Output

```
missing field: File
```

</p>
</details>

<details><summary>Example (Flag)</summary>
<p>



```go
package main

import (
	"fmt"
	"os"

	"github.com/chriso345/clifford"
)

func main() {
	target := struct {
		clifford.Clifford `name:"sampleapp"`

		Flag struct {
			Value             bool
			clifford.Clifford `short:"f" long:"flag" desc:"A sample boolean flag"`
		}
	}{}

	// Simulate command line arguments
	os.Args = []string{"sampleapp", "-f"}

	err := clifford.Parse(&target)
	if err != nil {
		panic(err)
	}
	fmt.Println("Flag value:", target.Flag.Value)
}
```

#### Output

```
Flag value: true
```

</p>
</details>

<details><summary>Example (Help_as_subcommand)</summary>
<p>

Example\_help\_as\_subcommand demonstrates generating help for a subcommand while keeping parent name in usage.

```go
package main

import (
	"fmt"
	"regexp"

	"github.com/chriso345/clifford"
)

func stripANSI(input string) string {
	re := regexp.MustCompile(`\x1b\[[0-9;]*[a-zA-Z]`)
	return re.ReplaceAllString(input, "")
}

func main() {
	parent := struct {
		clifford.Clifford `name:"app" desc:"Parent app"`
		clifford.Help

		Serve struct {
			clifford.Subcommand `name:"serve" desc:"Start server"`
			Port                struct {
				Value             int
				clifford.Clifford `long:"port" desc:"Port number"`
			}
		}
	}{}

	sub := parent.Serve
	help, err := clifford.BuildHelpWithParent(&parent, "serve", &sub, false)
	if err != nil {
		panic(err)
	}
	fmt.Println(stripANSI(help))
}
```

#### Output

```
Usage: app serve [OPTIONS]

Options:
  --port [PORT]  Port number
```

</p>
</details>

<details><summary>Example (Help_output)</summary>
<p>

Example\_help\_output demonstrates building help for a parent with multiple subcommands.

```go
package main

import (
	"fmt"
	"regexp"

	"github.com/chriso345/clifford"
)

func main() {
	// Parent help shows subcommands and their descriptions
	target := struct {
		clifford.Clifford `name:"app" desc:"App for help output"`
		clifford.Help

		Serve struct {
			clifford.Subcommand `name:"serve" desc:"Start the server"`
		}
		Status struct {
			clifford.Subcommand `name:"status" desc:"Show server status"`
		}
	}{}

	help, err := clifford.BuildHelp(&target, false)
	if err != nil {
		panic(err)
	}
	fmt.Println(stripANSI(help))
}

func stripANSI(input string) string {
	re := regexp.MustCompile(`\x1b\[[0-9;]*[a-zA-Z]`)
	return re.ReplaceAllString(input, "")
}
```

</p>
</details>

<details><summary>Example (Inline)</summary>
<p>



```go
package main

import (
	"fmt"
	"os"

	"github.com/chriso345/clifford"
)

func main() {
	args := struct {
		clifford.Clifford `name:"dmenu"`
		clifford.Help
		clifford.Version `version:"0.1.0"`

		Menu struct {
			Value             string
			clifford.Clifford `long:"menu" desc:"Start in menu mode"`

			NoConfig bool   `long:"no-config" desc:"Do not load config file"`
			MaxItems int    `short:"n" long:"max-items" desc:"Override max items (-1 for auto)"`
			LogLevel string `long:"log-level" desc:"Set log level (debug|info|warn|error)"`
			DryRun   bool   `long:"dry-run" desc:"Do not execute actions; print selection instead"`
			Timeout  int    `long:"timeout" desc:"Auto-exit after N seconds of inactivity (0 disables)"`
		}

		Dmenu struct {
			clifford.Clifford `long:"dmenu" desc:"Start in dmenu mode"`
			MaxItems          int    `short:"n" long:"max-items" desc:"Override max items (-1 for auto)"`
			LogLevel          string `long:"log-level" desc:"Set log level (debug|info|warn|error)"`
			DryRun            bool   `long:"dry-run" desc:"Do not execute actions; print selection instead"`
			Timeout           int    `long:"timeout" desc:"Auto-exit after N seconds of inactivity (0 disables)"`
		}

		Apps struct {
			clifford.Clifford `long:"apps" desc:"Start in apps mode"`
			DesktopDir        string `long:"desktop-dir" desc:"Path to .desktop files"`
			LogLevel          string `long:"log-level" desc:"Set log level (debug|info|warn|error)"`
			DryRun            bool   `long:"dry-run" desc:"Do not launch apps; print selection instead"`
		}
	}{}

	// Simulate command line arguments
	os.Args = []string{"greg", "menu", "--max-items", "20", "--log-level", "debug"}

	err := clifford.Parse(&args)
	if err != nil {
		panic(err)
	}

	fmt.Println("Mode: menu")
	fmt.Println("MaxItems:", args.Menu.MaxItems)
	fmt.Println("LogLevel:", args.Menu.LogLevel)
}
```

#### Output

```
Mode: menu
MaxItems: 20
LogLevel: debug
```

</p>
</details>

<details><summary>Example (List_subcommands)</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/chriso345/clifford"
)

func main() {
	// Build help that lists multiple subcommands and print a marker line for the example.
	target := struct {
		clifford.Clifford `name:"app" desc:"Application with multiple subcommands"`
		clifford.Help

		Serve struct {
			clifford.Subcommand `name:"serve" desc:"Start the server"`
		}
		Status struct {
			clifford.Subcommand `name:"status" desc:"Show server status"`
		}
	}{}

	if _, err := clifford.BuildHelp(&target, false); err != nil {
		panic(err)
	}
	fmt.Println("Subcommands:")
}
```

#### Output

```
Subcommands:
```

</p>
</details>

<details><summary>Example (Nested_subcommands)</summary>
<p>



```go
package main

import (
	"fmt"
	"os"

	"github.com/chriso345/clifford"
)

func main() {
	// Demonstrate nested subcommands: app remote add --name foo
	os.Args = []string{"app", "remote", "add", "--name", "origin"}
	target := struct {
		clifford.Clifford `name:"app"`
		clifford.Help

		Remote struct {
			clifford.Subcommand `name:"remote" desc:"Remote operations"`
			Add                 struct {
				clifford.Subcommand `name:"add" desc:"Add a remote"`
				Name                struct {
					Value             string
					clifford.Clifford `long:"name" desc:"Name of the remote"`
				}
			}
		}
	}{}

	err := clifford.Parse(&target)
	if err != nil {
		panic(err)
	}
	fmt.Println("Remote add name:", target.Remote.Add.Name.Value)
}
```

#### Output

```
Remote add name: origin
```

</p>
</details>

<details><summary>Example (Readme)</summary>
<p>



```go
package main

import (
	"fmt"
	"os"

	"github.com/chriso345/clifford"
)

func main() {
	// Simulate command line arguments
	os.Args = []string{"mytool", "--name", "Alice", "-a", "30"}

	target := struct {
		clifford.Clifford `name:"mytool"`   // Set the name of the CLI tool
		clifford.Version  `version:"1.2.3"` // Enable automatic version flag
		clifford.Help                       // Enable automatic help flags

		Name struct {
			Value             string
			clifford.Clifford `short:"n" long:"name" desc:"User name"`
		}
		Age struct {
			Value             string
			clifford.ShortTag // auto generates -a
			clifford.LongTag  // auto generates --age
			clifford.Desc     `desc:"Age of the user"`
		}
	}{}

	err := clifford.Parse(&target)
	if err != nil {
		panic(err)
	}

	fmt.Printf("Name: %s\n", target.Name.Value)
	fmt.Printf("Age: %s\n", target.Age.Value)
}
```

#### Output

```
Name: Alice
Age: 30
```

</p>
</details>

<details><summary>Example (Simple_cli)</summary>
<p>



```go
package main

import (
	"fmt"
	"os"

	"github.com/chriso345/clifford"
)

func main() {
	// Simulate command line arguments
	os.Args = []string{"example_cli", "bob"}

	target := struct {
		clifford.Clifford `name:"example_cli"` // This is the name of the cli command
		clifford.Version  `version:"1.0.0"`
		clifford.Help

		Name struct {
			Value string
		}
	}{}

	err := clifford.Parse(&target)
	if err != nil {
		panic(err)
	}

	if target.Name.Value != "" {
		fmt.Println("Hello, " + target.Name.Value + "!")
	} else {
		fmt.Println("Hello, World!")
	}
}
```

#### Output

```
Hello, bob!
```

</p>
</details>

<details><summary>Example (Subcommand)</summary>
<p>



```go
package main

import (
	"fmt"
	"os"

	"github.com/chriso345/clifford"
)

func main() {
	// Demonstrate a single-level subcommand parse
	os.Args = []string{"app", "serve", "--port", "8080"}

	target := struct {
		clifford.Clifford `name:"app"`
		clifford.Help

		Serve struct {
			clifford.Subcommand `name:"serve" desc:"Start the server"`
			Port                struct {
				Value             int
				clifford.Clifford `long:"port" desc:"Port to run the server on"`
			}
		}

		Status struct {
			clifford.Subcommand `name:"status" desc:"Show server status"`
		}
	}{}

	err := clifford.Parse(&target)
	if err != nil {
		panic(err)
	}

	fmt.Println("Serve port:", target.Serve.Port.Value)
}
```

#### Output

```
Serve port: 8080
```

</p>
</details>

<details><summary>Example (Unknown_subcommand)</summary>
<p>

Example\_unknown\_subcommand shows the parser returning a helpful suggestion for mistyped subcommands.

```go
package main

import (
	"fmt"
	"os"

	"github.com/chriso345/clifford"
)

func main() {
	os.Args = []string{"app", "srve"}
	target := struct {
		clifford.Clifford `name:"app"`
		clifford.Help

		Serve struct {
			clifford.Subcommand `name:"serve" desc:"Start server"`
		}
	}{}

	err := clifford.Parse(&target)
	if err != nil {
		fmt.Println(err.Error())
	}
}
```

#### Output

```
unknown subcommand: srve (did you mean "serve"?)
```

</p>
</details>

## Index

- [Variables](<#variables>)
- [func BuildHelpWithParent\(parent any, subName string, subTarget any, long bool\) \(string, error\)](<#BuildHelpWithParent>)
- [func ModuleVersion\(\) string](<#ModuleVersion>)
- [type Clifford](<#Clifford>)
- [type Desc](<#Desc>)
- [type Help](<#Help>)
- [type LongTag](<#LongTag>)
- [type Required](<#Required>)
- [type ShortTag](<#ShortTag>)
- [type Subcommand](<#Subcommand>)
- [type Version](<#Version>)


## Variables

<a name="BuildHelp"></a>BuildHelp generates and returns a formatted help message for a CLI tool defined by the given struct pointer. BuildHelp also takes in a boolean \`long\` parameter that, if set to true, will print a more detailed help message with the long\_about description

The \`target\` must be a pointer to a struct that embeds a \`Clifford\` field with a \`name\` tag. This tag specifies the CLI tool's name and is displayed in the usage header.

The function inspects the struct to determine CLI arguments and options, including those marked as required. It outputs a help string that includes:

- The usage line with the command name and expected arguments
- A section for required arguments \(based on \`Required\` tags\)
- A section for optional flags \(based on \`short\` or \`long\` tags\)

If no \`name\` tag is found on any embedded \`Clifford\` field, the function returns an error.

Example:

```
target := struct {
	clifford.Clifford `name:"mytool"`

	Filename struct {
		Value    string
		clifford.Required
		clifford.Desc `desc:"Input file path"`
	}

	Verbose struct {
		Value    bool
		clifford.Clifford `short:"v" long:"verbose" desc:"Enable verbose output"`
	}
}{}

helpText, err := clifford.BuildHelp(&target, false)
if err != nil {
	log.Fatal(err)
}
fmt.Println(helpText)
```

```go
var BuildHelp = display.BuildHelp
```

<a name="BuildVersion"></a>BuildVersion returns a formatted version string for the CLI tool defined by the provided struct pointer.

The \`target\` must be a pointer to a struct that embeds a \`Clifford\` field with a \`version\` tag. This tag specifies the version number of the CLI tool. If no version tag is found, the function returns an error.

This function is automatically invoked by \`Parse\` if the CLI arguments include \`\-\-version\`.

Example:

```
target := struct {
	clifford.Clifford `name:"mytool" version:"1.2.3"`
}{}

version, err := clifford.BuildVersion(&target)
if err != nil {
	log.Fatal(err)
}
fmt.Println(version) // Output: mytool v1.2.3
```

```go
var BuildVersion = display.BuildVersion
```

<a name="Parse"></a>Parse parses command\-line arguments into the provided target struct.

The target must be a pointer to a struct where each field represents either a CLI argument or a group of options. Each sub\-struct should contain a \`Value\` field to hold the parsed value, and may be annotated using \`clifford\` tags or helper types like \`ShortTag\`, \`LongTag\`, \`Required\`, and \`Desc\`.

If the first argument passed to the CLI is \`\-h\` or \`\-\-help\`, Parse will automatically call BuildHelp and exit the program.

Usage:

```
target := struct {
	clifford.Clifford `name:"mytool"`

	Name struct {
		Value    string
		clifford.Clifford `short:"n" long:"name" desc:"User name"`
	}

	Age struct {
		Value    string
		clifford.ShortTag // Auto-generates: -a
		clifford.LongTag  // Auto-generates: --age
		clifford.Desc     `desc:"Age of the user"`
	}
}{}

err := clifford.Parse(&target)
if err != nil {
	log.Fatal(err)
}
```

```go
var Parse = core.Parse
```

<a name="BuildHelpWithParent"></a>
## func [BuildHelpWithParent](<https://github.com/ChrisO345/clifford/blob/master/clifford.go#L108>)

```go
func BuildHelpWithParent(parent any, subName string, subTarget any, long bool) (string, error)
```

BuildHelpWithParent exposes the subcommand\-aware help builder for callers/tests.

<a name="ModuleVersion"></a>
## func [ModuleVersion](<https://github.com/ChrisO345/clifford/blob/master/version.go#L10>)

```go
func ModuleVersion() string
```

ModuleVersion returns the version of the clifford module, if available.

<a name="Clifford"></a>
## type [Clifford](<https://github.com/ChrisO345/clifford/blob/master/types.go#L32>)

Clifford is the primary metadata marker for CLI definitions.

It can be embedded in the root struct to define metadata for the CLI tool itself, such as its name, version, or other global settings via struct tags.

It can also be embedded into sub\-structs to provide additional annotations such as \`short\`, \`long\`, \`desc\`, and \`required\`, either directly or via helper types.

Usage:

Root\-level CLI tool definition:

```
cli := struct {
    Clifford `name:"mytool" version:"1.0.0"`
    ...
}{}
```

Sub\-struct flag definition using Clifford for metadata:

```
cli := struct {
    Clifford `name:"mytool"`

    Name struct {
        Value    string
        Clifford `short:"n" long:"name" desc:"User name"`
    }
}{}
```

```go
type Clifford = core.Clifford
```

<a name="Desc"></a>
## type [Desc](<https://github.com/ChrisO345/clifford/blob/master/types.go#L138>)

Desc is a helper type that allows you to annotate a CLI option or argument with a description.

This description will be included in the generated help output.

Usage:

```
cli := struct {
    Name struct {
        Value string
        Desc  `desc:"Name of the user"`
    }
}{}
```

```go
type Desc = core.Desc
```

<a name="Help"></a>
## type [Help](<https://github.com/ChrisO345/clifford/blob/master/types.go#L70>)

Help is a marker type that enables the automatic \`\-\-help\` and \`\-h\` flag handling.

When embedded in the root struct, this allows the user to request usage help. If \`\-h\` or \`\-\-help\` is passed as the first CLI argument, Clifford will invoke BuildHelp automatically and exit gracefully.

Usage:

```
cli := struct {
    Clifford `name:"mytool"`
    Help
    ...
}{}
```

```go
type Help = core.Help
```

<a name="LongTag"></a>
## type [LongTag](<https://github.com/ChrisO345/clifford/blob/master/types.go#L110>)

LongTag is a helper type used to automatically generate a long flag \(e.g. \`\-\-name\`\) for a CLI option based on the parent struct field name.

Usage:

```
cli := struct {
    Name struct {
        Value   string
        LongTag // Will auto-generate: --name
    }
}{}
```

```go
type LongTag = core.LongTag
```

<a name="Required"></a>
## type [Required](<https://github.com/ChrisO345/clifford/blob/master/types.go#L124>)

Required is a marker type that indicates the associated argument or flag is required.

If a required argument or flag is not provided in the CLI input, the parser will return an error.

Usage:

```
cli := struct {
    File struct {
        Value    string
        Required // Must be supplied on the command line
    }
}{}
```

```go
type Required = core.Required
```

<a name="ShortTag"></a>
## type [ShortTag](<https://github.com/ChrisO345/clifford/blob/master/types.go#L97>)

ShortTag is a helper type used to automatically generate a short flag \(e.g. \`\-n\`\) for a CLI option based on the parent struct field name.

You can embed it in a sub\-struct to indicate that a short flag should be derived from the first letter of the field name, unless explicitly overridden.

Usage:

```
cli := struct {
    Name struct {
        Value    string
        ShortTag // Will auto-generate: -n
    }
}{}
```

```go
type ShortTag = core.ShortTag
```

<a name="Subcommand"></a>
## type [Subcommand](<https://github.com/ChrisO345/clifford/blob/master/types.go#L81>)

Subcommand is a helper exported from core to mark fields as subcommands. Usage:

```
cli := struct {
    CommandA struct {
        Value      string
        Subcommand // Marks this field as a subcommand
    }
}{}
```

```go
type Subcommand = core.Subcommand
```

<a name="Version"></a>
## type [Version](<https://github.com/ChrisO345/clifford/blob/master/types.go#L55>)

Version is a marker type that indicates the CLI tool supports a \`\-\-version\` flag.

When included in the root struct, \`Version\` enables version display logic. If the \`version\` struct tag is set, Clifford will use it directly. If left empty, Clifford may attempt to auto\-detect or fallback to a default \(implementation dependent\).

Usage:

// Automatic detection or programmatic assignment

```
cli := struct {
    Clifford `name:"mytool"`
    Version
}{}
```

// Static version string via struct tag

```
cli := struct {
    Clifford `name:"mytool"`
    Version `version:"1.0.0"`
}{}
```

```go
type Version = core.Version
```

# core

```go
import "github.com/chriso345/clifford/core"
```

Package core contains the core logic for parsing command\-line arguments into user\-defined structs using reflection.

It provides the primary parsing function and defines marker types used to annotate struct fields with CLI metadata such as flags, required fields, and descriptions.

This package is intended to be used internally by higher\-level packages, but some core functions may be exposed for advanced use cases.

## Index

- [func Parse\(target any\) error](<#Parse>)
- [type Clifford](<#Clifford>)
- [type Desc](<#Desc>)
- [type Help](<#Help>)
- [type LongTag](<#LongTag>)
- [type Required](<#Required>)
- [type ShortTag](<#ShortTag>)
- [type Subcommand](<#Subcommand>)
- [type Version](<#Version>)


<a name="Parse"></a>
## func [Parse](<https://github.com/ChrisO345/clifford/blob/master/core/parse.go#L781>)

```go
func Parse(target any) error
```



<a name="Clifford"></a>
## type [Clifford](<https://github.com/ChrisO345/clifford/blob/master/core/tags.go#L15>)



```go
type Clifford struct{}
```

<a name="Desc"></a>
## type [Desc](<https://github.com/ChrisO345/clifford/blob/master/core/tags.go#L24>)



```go
type Desc struct{}
```

<a name="Help"></a>
## type [Help](<https://github.com/ChrisO345/clifford/blob/master/core/tags.go#L17>)



```go
type Help struct{}
```

<a name="LongTag"></a>
## type [LongTag](<https://github.com/ChrisO345/clifford/blob/master/core/tags.go#L22>)



```go
type LongTag struct{}
```

<a name="Required"></a>
## type [Required](<https://github.com/ChrisO345/clifford/blob/master/core/tags.go#L23>)



```go
type Required struct{}
```

<a name="ShortTag"></a>
## type [ShortTag](<https://github.com/ChrisO345/clifford/blob/master/core/tags.go#L21>)



```go
type ShortTag struct{}
```

<a name="Subcommand"></a>
## type [Subcommand](<https://github.com/ChrisO345/clifford/blob/master/core/tags.go#L28>)

Subcommand is a marker type used to indicate that a struct field represents a subcommand. Embed this in a sub\-struct to mark it as a subcommand target.

```go
type Subcommand bool
```

<a name="Version"></a>
## type [Version](<https://github.com/ChrisO345/clifford/blob/master/core/tags.go#L16>)



```go
type Version struct{}
```

# display

```go
import "github.com/chriso345/clifford/display"
```

Package display provides utilities for generating user\-facing CLI output, including help messages, version strings, and ANSI formatting.

It handles formatting of help text based on the CLI argument struct tags, and building version information to display in the CLI.

This package is separated from core parsing logic to isolate display concerns.

## Index

- [func BuildHelp\(target any, long bool\) \(string, error\)](<#BuildHelp>)
- [func BuildHelpWithParent\(parent any, subName string, subTarget any, long bool\) \(string, error\)](<#BuildHelpWithParent>)
- [func BuildVersion\(target any\) \(string, error\)](<#BuildVersion>)


<a name="BuildHelp"></a>
## func [BuildHelp](<https://github.com/ChrisO345/clifford/blob/master/display/help.go#L16>)

```go
func BuildHelp(target any, long bool) (string, error)
```



<a name="BuildHelpWithParent"></a>
## func [BuildHelpWithParent](<https://github.com/ChrisO345/clifford/blob/master/display/subhelp.go#L11>)

```go
func BuildHelpWithParent(parent any, subName string, subTarget any, long bool) (string, error)
```

BuildHelpWithParent builds help for a subcommand while showing the parent application name and the subcommand name together \(e.g. "app server \[OPTIONS\]"\).

<a name="BuildVersion"></a>
## func [BuildVersion](<https://github.com/ChrisO345/clifford/blob/master/display/version.go#L11>)

```go
func BuildVersion(target any) (string, error)
```



# errors

```go
import "github.com/chriso345/clifford/errors"
```

Package errors defines error types and utilities related to CLI parsing and validation within the clifford library.

It centralizes error constants and custom error implementations for consistent error handling across the library.

## Index

- [Variables](<#variables>)
- [func NewMissingArg\(field string\) error](<#NewMissingArg>)
- [func NewParseError\(msg string\) error](<#NewParseError>)
- [func NewUnknownSubcommand\(name, suggestion string\) error](<#NewUnknownSubcommand>)
- [func NewUnsupportedField\(field, typ string\) error](<#NewUnsupportedField>)
- [type MissingArgError](<#MissingArgError>)
  - [func \(e MissingArgError\) Error\(\) string](<#MissingArgError.Error>)
- [type ParseError](<#ParseError>)
  - [func \(e ParseError\) Error\(\) string](<#ParseError.Error>)
- [type UnknownSubcommandError](<#UnknownSubcommandError>)
  - [func \(e UnknownSubcommandError\) Error\(\) string](<#UnknownSubcommandError.Error>)
- [type UnsupportedFieldTypeError](<#UnsupportedFieldTypeError>)
  - [func \(e UnsupportedFieldTypeError\) Error\(\) string](<#UnsupportedFieldTypeError.Error>)


## Variables

<a name="ErrParse"></a>

```go
var (
    ErrParse                = stderrors.New("parse error")
    ErrMissingArg           = stderrors.New("missing argument")
    ErrUnknownSubcommand    = stderrors.New("unknown subcommand")
    ErrUnsupportedFieldType = stderrors.New("unsupported field type")
)
```

<a name="NewMissingArg"></a>
## func [NewMissingArg](<https://github.com/ChrisO345/clifford/blob/master/errors/errors.go#L48>)

```go
func NewMissingArg(field string) error
```



<a name="NewParseError"></a>
## func [NewParseError](<https://github.com/ChrisO345/clifford/blob/master/errors/errors.go#L47>)

```go
func NewParseError(msg string) error
```

Helper constructors

<a name="NewUnknownSubcommand"></a>
## func [NewUnknownSubcommand](<https://github.com/ChrisO345/clifford/blob/master/errors/errors.go#L49>)

```go
func NewUnknownSubcommand(name, suggestion string) error
```



<a name="NewUnsupportedField"></a>
## func [NewUnsupportedField](<https://github.com/ChrisO345/clifford/blob/master/errors/errors.go#L52>)

```go
func NewUnsupportedField(field, typ string) error
```



<a name="MissingArgError"></a>
## type [MissingArgError](<https://github.com/ChrisO345/clifford/blob/master/errors/errors.go#L22>)

MissingArgError indicates a required positional or flag was not provided.

```go
type MissingArgError struct{ Field string }
```

<a name="MissingArgError.Error"></a>
### func \(MissingArgError\) [Error](<https://github.com/ChrisO345/clifford/blob/master/errors/errors.go#L24>)

```go
func (e MissingArgError) Error() string
```



<a name="ParseError"></a>
## type [ParseError](<https://github.com/ChrisO345/clifford/blob/master/errors/errors.go#L17>)

ParseError represents a generic parsing error produced by the CLI parser. It is intended for user\-facing messages.

```go
type ParseError struct{ Msg string }
```

<a name="ParseError.Error"></a>
### func \(ParseError\) [Error](<https://github.com/ChrisO345/clifford/blob/master/errors/errors.go#L19>)

```go
func (e ParseError) Error() string
```



<a name="UnknownSubcommandError"></a>
## type [UnknownSubcommandError](<https://github.com/ChrisO345/clifford/blob/master/errors/errors.go#L30>)

UnknownSubcommandError indicates the user invoked a subcommand that does not exist. Suggestion, if present, is a close match the user may have intended.

```go
type UnknownSubcommandError struct{ Name, Suggestion string }
```

<a name="UnknownSubcommandError.Error"></a>
### func \(UnknownSubcommandError\) [Error](<https://github.com/ChrisO345/clifford/blob/master/errors/errors.go#L32>)

```go
func (e UnknownSubcommandError) Error() string
```



<a name="UnsupportedFieldTypeError"></a>
## type [UnsupportedFieldTypeError](<https://github.com/ChrisO345/clifford/blob/master/errors/errors.go#L40>)

UnsupportedFieldTypeError indicates the CLI contains an unsupported field type.

```go
type UnsupportedFieldTypeError struct{ Field, Type string }
```

<a name="UnsupportedFieldTypeError.Error"></a>
### func \(UnsupportedFieldTypeError\) [Error](<https://github.com/ChrisO345/clifford/blob/master/errors/errors.go#L42>)

```go
func (e UnsupportedFieldTypeError) Error() string
```



# test

```go
import "github.com/chriso345/clifford/test"
```

## Index

- [type CLIArgs](<#CLIArgs>)


<a name="CLIArgs"></a>
## type [CLIArgs](<https://github.com/ChrisO345/clifford/blob/master/test/main.go#L10-L32>)



```go
type CLIArgs struct {
    clifford.Clifford `name:"app"`
    clifford.Help     `type:"both"`
    clifford.Version  `version:"0.1.0"`
    clifford.Desc     `desc:"An example application demonstrating clifford features"`

    Serve struct {
        clifford.Subcommand `name:"server"`
        clifford.Help
        clifford.Desc `desc:"Start the server"`

        Port struct {
            Value             int `default:"8080"`
            clifford.Clifford `long:"port"`
            clifford.Desc     `desc:"Port to run the server on"`
        }

        Verbose struct {
            Value             bool
            clifford.Clifford `short:"v" long:"verbose" desc:"Enable verbose output"`
        }
    }
}
```

# common

```go
import "github.com/chriso345/clifford/internal/common"
```

Package common provides internal utility functions and helpers used across the clifford library.

This package is intended for internal use only and should not be imported by external clients.

## Index

- [func ArgsIndexOf\(args \[\]string, s string\) int](<#ArgsIndexOf>)
- [func GetStructType\(v any\) reflect.Type](<#GetStructType>)
- [func GetTagsFromEmbedded\(t reflect.Type, fieldName string\) map\[string\]string](<#GetTagsFromEmbedded>)
- [func IsStructPtr\(v any\) bool](<#IsStructPtr>)
- [func MetaArgEnabled\(s string, target any\) bool](<#MetaArgEnabled>)


<a name="ArgsIndexOf"></a>
## func [ArgsIndexOf](<https://github.com/ChrisO345/clifford/blob/master/internal/common/utils.go#L58>)

```go
func ArgsIndexOf(args []string, s string) int
```

ArgsIndexOf returns the index of the first occurrence of s in args, or \-1 if not found.

<a name="GetStructType"></a>
## func [GetStructType](<https://github.com/ChrisO345/clifford/blob/master/internal/common/utils.go#L74>)

```go
func GetStructType(v any) reflect.Type
```

GetStructType returns the reflect.Type of the underlying struct pointer.

<a name="GetTagsFromEmbedded"></a>
## func [GetTagsFromEmbedded](<https://github.com/ChrisO345/clifford/blob/master/internal/common/utils.go#L9>)

```go
func GetTagsFromEmbedded(t reflect.Type, fieldName string) map[string]string
```

GetTagsFromEmbedded retrieves tags from embedded structs in the target struct.

<a name="IsStructPtr"></a>
## func [IsStructPtr](<https://github.com/ChrisO345/clifford/blob/master/internal/common/utils.go#L68>)

```go
func IsStructPtr(v any) bool
```

IsStructPtr checks if the provided value is a pointer to a struct.

<a name="MetaArgEnabled"></a>
## func [MetaArgEnabled](<https://github.com/ChrisO345/clifford/blob/master/internal/common/utils.go#L80>)

```go
func MetaArgEnabled(s string, target any) bool
```

MetaArgEnabled returns true if the root struct has a \`Clifford\` field with tag or name matching s or if the field name itself matches s.

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
